<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet href="http://cestlaz.github.io/assets/xml/atom.xsl" type="text/xsl media="all"?>
<feed xml:lang="en" xmlns="http://www.w3.org/2005/Atom">
  <title>Posts about programming</title>
  <id>http://cestlaz.github.io/categories/programming.atom</id>
  <updated>2017-06-15T00:04:49Z</updated>
  <author>
    <name>Mike Zamansky</name>
  </author>
  <link rel="self" type="application/atom+xml" href="http://cestlaz.github.io/categories/programming.atom"/>
  <link rel="alternate" type="text/html" href="http://cestlaz.github.io/categories/programming/"/>
  <generator uri="https://getnikola.com/">Nikola</generator>
  <entry>
    <title>A* is born</title>
    <id>http://cestlaz.github.io/posts/a-star-is-born/</id>
    <updated>2017-06-05T18:42:55-04:00</updated>
    <published>2017-06-05T18:42:55-04:00</published>
    <author>
      <name>Mike Zamansky</name>
    </author>
    <link rel="alternate" type="text/html" href="http://cestlaz.github.io/posts/a-star-is-born/"/>
    <summary type="html">&lt;p&gt;
Over on the &lt;a href="https://cseducators.stackexchange.com/"&gt;CS Educator StachExchange&lt;/a&gt;, which is in private beta for a
few more days, I saw a post asking about how to introduce the &lt;a href="https://en.wikipedia.org/wiki/A*_search_algorithm"&gt;A*
search algorithm&lt;/a&gt;. 
&lt;/p&gt;

&lt;p&gt;
I taught A* as part of the APCS class at Stuy so I thought I'd talk
about what I did here.
&lt;/p&gt;

&lt;p&gt;
Some time around mid year, we get to intermediate recursion. This is
about the time, give or take, when we talk about the nlogn sorts.
&lt;/p&gt;

&lt;p&gt;
We also build a recursive maze solver. It's a nice algorithm and a
nice little program. It's around 15 lines of code to perform a
recursive depth first search:
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://cestlaz.github.io/img/astar/dfs.gif" alt="dfs.gif" align="center" height="200px"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
The basic algorithm is:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* solve the maze from an x,ylocation */&lt;/span&gt;
&lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;we&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;Yay&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="n"&gt;We&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;exit&lt;/span&gt;
  &lt;span class="nf"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;we&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;wall&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;previous&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;mark&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;
     &lt;span class="nf"&gt;solve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
It's a nice lesson because in addition to all the recursion stuff, we
also get to talk about state space, state space search, backtracking,
efficiency concerns and much more. After we finish the maze solver, we also talk about
other problems that can be similarly examined using state-space search
like the knights tour and N-queens problems. 
&lt;/p&gt;

&lt;p&gt;
A month or so later, when we're learning about stacks and queues as
data structures, we revisit the maze solver. This time we solve the
problem in a more general way. We talk about using a data structure to
hold the set of nodes that we're aware of and that we want to visit
next. 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;structure&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;structure&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;structure&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;goal&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;we&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;every&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="n"&gt;adjacent&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;isn&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;yet&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;mark&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;
     &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;structure&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
As we write the solution, we see that using a queue for this
data structure yields a breadth first search:
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://cestlaz.github.io/img/astar/bfs.gif" alt="bfs.gif" align="center" height="200px"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
while using a stack yields depth first. 
&lt;/p&gt;

&lt;p&gt;
All of this leads to a discussion as to how deciding on which
locations to look at next can greatly influence the steps to the
exit. From here it's easy to see that you can use a heuristic to order
the nodes in our data structure so that we explore "better"
possibilities first. The data structure becomes a priority queue and
we finally get to both "best first" and A* search:
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://cestlaz.github.io/img/astar/astar.gif" alt="astar.gif" align="center" height="200px"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
It's a nice sequence of lessons, albeit lessons spread out over
months. The end result is that the students see both the need and
motivation for something like A* and they see that it's not hard to
implement. One basic routine where you can plug in one of three data
structures - stack, queue, or priority queue to get very different
results.
&lt;/p&gt;</summary>
    <category term="algorithms" label="algorithms"/>
    <category term="cs" label="cs"/>
    <category term="data-structures" label="data structures"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>Advent of Code 2016 - Check your data</title>
    <id>http://cestlaz.github.io/posts/advent-of-code-2016-check-data/</id>
    <updated>2016-12-10T11:25:38-05:00</updated>
    <published>2016-12-10T11:25:38-05:00</published>
    <author>
      <name>Mike Zamansky</name>
    </author>
    <link rel="alternate" type="text/html" href="http://cestlaz.github.io/posts/advent-of-code-2016-check-data/"/>
    <summary type="html">&lt;p&gt;
I'm spending the weekend up in Michigan. Visiting my brother and is
family. We're here to see the &lt;a href="http://umgass.org"&gt;UMGASS&lt;/a&gt; production of Gilbert and
Sullivan's &lt;a href="http://www.umgass.org/current-production"&gt;The Sorcerer&lt;/a&gt;. Batya also came up from Cornell to join us so
the two families are all togehter for the first time in about 10
years.
&lt;/p&gt;

&lt;p&gt;
This hasn't left much time for &lt;a href="http://adventofcode.com"&gt;Advent of Code&lt;/a&gt; but I did manage to
finish yesterday's challenge this morning.
&lt;/p&gt;

&lt;p&gt;
What took me so long? Much like last year, it was &lt;a href="http://cestlaz.github.io/posts/2015-12-17-im-an-idiot.html/"&gt;because I'm an
idiot&lt;/a&gt;. 
&lt;/p&gt;

&lt;p&gt;
The &lt;a href="http://adventofcode.com/2016/day/9"&gt;problem&lt;/a&gt; seemed pretty straighforward. I coded a solution and it
worked for all the test cases. I tried it on my data set but
the grader said the answer was wrong. I went through the problem a
number of times as well sa my code. I figured I either mis-interpreted
the question or had some bug. I found neither to be true.
&lt;/p&gt;

&lt;p&gt;
After some frustration, I went over to the Advent of Code &lt;a href="https://www.reddit.com/r/adventofcode/"&gt;subreddit&lt;/a&gt;
grabbed a couple of posted solutions (trying not to look at them) and
ran both on my data - those solutions got the same answer on my data
set as I did. 
&lt;/p&gt;

&lt;p&gt;
This morning, I asked Batya to look over my code and the problem (it's
always good to have a daughter that's smarted than you are) but she
saw no problems.
&lt;/p&gt;

&lt;p&gt;
Finally, I emailed my buddy JonAlf since I know he completed the problem. He sent back his answer along
with his data set and I got the same answer as he did on his data.
&lt;/p&gt;

&lt;p&gt;
What could be the problem.
&lt;/p&gt;

&lt;p&gt;
His data set was about 12k characters long, mine was 4k. Something had
to be wrong here. I went back to the Advent of Code site and grabbed
the data set again. This time, I went to the page and did a "save-as"
to save it - last time, I cut and pasted.
&lt;/p&gt;

&lt;p&gt;
The cut and paste version was 4k, the save-as was 12k. This time it
worked and was accepted and I also finished part 2 in short order.
&lt;/p&gt;

&lt;p&gt;
The moral of the story – make sure you check the integrity of your
data set - you'll never get the right answer if you're working with
the wrong data.
&lt;/p&gt;

&lt;p&gt;
In case anyone's interested, you can find my AoC code &lt;a href="https://github.com/zamansky/advent2016"&gt;here&lt;/a&gt;.
&lt;/p&gt;</summary>
    <category term="cs" label="cs"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>A Teacher looks at Advent of Code 2016 #2</title>
    <id>http://cestlaz.github.io/posts/advent-of-code-2016-2/</id>
    <updated>2016-12-08T08:40:49-05:00</updated>
    <published>2016-12-08T08:40:49-05:00</published>
    <author>
      <name>Mike Zamansky</name>
    </author>
    <link rel="alternate" type="text/html" href="http://cestlaz.github.io/posts/advent-of-code-2016-2/"/>
    <summary type="html">&lt;p&gt;
Today we're looking at &lt;a href="http://adventofcode.com"&gt;Advent of Code&lt;/a&gt; 2016 &lt;a href="http://adventofcode.com/2016/day/2"&gt;number 2&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
To change things up, I thought I'd do a video where I live code a solution.
&lt;/p&gt;

&lt;p&gt;
The solution I present is pretty straightforward - use a 2D array (or
technically, an array of strings) to represent the keypad, parse the
input, and follow the input instructions to build the code. 
&lt;/p&gt;

&lt;p&gt;
One of the things I really like about Advent of Code is that every
problem has two parts and depending on how you solved part 1, you may
or may not have extra work to do for part 2.
&lt;/p&gt;

&lt;p&gt;
A couple of years ago, I wrote about one of the coding techniques I
try to convey to my students. The idea of &lt;a href="http://cestlaz.github.io/posts/2014-02-26-change-the-data.md"&gt;changing the data&lt;/a&gt; to take
away edge and special cases. 
&lt;/p&gt;

&lt;p&gt;
Part two of this problem is a perfect time to use that technique.
&lt;/p&gt;

&lt;p&gt;
Here's the video, I hope you enjoy it:
&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/EC8gSrYQ11g" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary>
    <category term="cs" label="cs"/>
    <category term="pedagogy" label="pedagogy"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>A Teacher looks at Advent of Code 2016 #1</title>
    <id>http://cestlaz.github.io/posts/advent-code-2016-1/</id>
    <updated>2016-12-06T10:46:17-05:00</updated>
    <published>2016-12-06T10:46:17-05:00</published>
    <author>
      <name>Mike Zamansky</name>
    </author>
    <link rel="alternate" type="text/html" href="http://cestlaz.github.io/posts/advent-code-2016-1/"/>
    <summary type="html">&lt;p&gt;
I recently &lt;a href="http://cestlaz.github.io/posts/advent-of-code-2016/"&gt;posted&lt;/a&gt; about &lt;a href="http://adventofcode.com"&gt;Advent of Code&lt;/a&gt; - a series of programming
problems relseased one a day. While they vary in terms of level of
difficulty, a number of them make nice problems for introductory to
mid level programming classes.
&lt;/p&gt;

&lt;p&gt;
I thought I'd share some of my thoughts on a few of them starting with
the first problem from this years competition.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://adventofcode.com/2016/day/1"&gt;Take a minute to read it over.&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
At first glance, it might seem to a young programmer that this problem
requires a two dimensional array - all about (x,y) coordinates but
then there's a problem - there are no limits on coordinates and we
can't make an unlimited size array.
&lt;/p&gt;

&lt;p&gt;
After thinking a bit, hopefully the programmer realizes that all they
need to do is keep track of the how the &lt;b&gt;&lt;b&gt;(x,y)&lt;/b&gt;&lt;/b&gt; location changes over
time. In the solution below, we start at &lt;b&gt;&lt;b&gt;(0,0)&lt;/b&gt;&lt;/b&gt; and count the steps as
we update two variables &lt;b&gt;&lt;b&gt;x&lt;/b&gt;&lt;/b&gt; and &lt;b&gt;&lt;b&gt;y&lt;/b&gt;&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
When we finish processing the moves, we have our current location in
&lt;b&gt;&lt;b&gt;(x,y)&lt;/b&gt;&lt;/b&gt; and we have the number of steps taken to get there.
&lt;/p&gt;

&lt;p&gt;
The solution below hsa a couple of niceties that a beginning
programmer might not know or use (and I'm not arguing that what's written is
superior in any way, it's just what I ended up writing).
&lt;/p&gt;

&lt;p&gt;
I make use of tuple destructuring:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
which assigns &lt;b&gt;&lt;b&gt;x&lt;/b&gt;&lt;/b&gt; to the first item in the tuple and &lt;b&gt;&lt;b&gt;y&lt;/b&gt;&lt;/b&gt; the
second. I used that a number of times 
&lt;/p&gt;

&lt;p&gt;
I also use a list  I call &lt;b&gt;&lt;b&gt;dirs&lt;/b&gt;&lt;/b&gt; to hold dx and dy values for the
four direcitons:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;dirs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This made it easier to to update the location based on the 4
directions. I could also have just used if statements.
&lt;/p&gt;

&lt;p&gt;
Here's all the code:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# assume our starting location is 0,0&lt;/span&gt;

&lt;span class="c1"&gt;# we start with d=0 -&amp;gt; facing north&lt;/span&gt;
&lt;span class="c1"&gt;# as we turn left or right, we can just increment or decrement d&lt;/span&gt;
&lt;span class="c1"&gt;# and dirs[d] will give us the appropriate dx and dy to update&lt;/span&gt;
&lt;span class="c1"&gt;# our locatoin for the next step&lt;/span&gt;
&lt;span class="n"&gt;dirs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;   
&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="c1"&gt;# This is only needed for part 2  - We track visited locations&lt;/span&gt;
&lt;span class="c1"&gt;# by adding them to the dictionary. If we try to add a location&lt;/span&gt;
&lt;span class="c1"&gt;# that's already been visited we know that we've found our final &lt;/span&gt;
&lt;span class="c1"&gt;# location&lt;/span&gt;
&lt;span class="c1"&gt;# locs={}  # uncomment this line for part 2&lt;/span&gt;


&lt;span class="n"&gt;totalsteps&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

    &lt;span class="c1"&gt;# the first char in i is the direction to turn in (L or R)&lt;/span&gt;
    &lt;span class="c1"&gt;# the rest represents the number of steps.&lt;/span&gt;
    &lt;span class="nb"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;steps&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:])&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s2"&gt;"L"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
	&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
	&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dirs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;steps&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;totalsteps&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;totalsteps&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

	&lt;span class="c1"&gt;# Uncomment this block for part 2&lt;/span&gt;
	&lt;span class="c1"&gt;# each time we have a new location, see if it's already in&lt;/span&gt;
	&lt;span class="c1"&gt;# locs, if it isn't, add it.&lt;/span&gt;
	&lt;span class="c1"&gt;# if it is, we're visiting somewhere twice so we're done.&lt;/span&gt;
	&lt;span class="c1"&gt;#if ((x,y) not in locs):&lt;/span&gt;
	&lt;span class="c1"&gt;#    locs[(x,y)]=1&lt;/span&gt;
	&lt;span class="c1"&gt;#else:&lt;/span&gt;
	&lt;span class="c1"&gt;#    print((x,y))&lt;/span&gt;
	&lt;span class="c1"&gt;#    print(abs(x)+abs(y)) # the answer&lt;/span&gt;
	&lt;span class="c1"&gt;#    sys.exit(0)&lt;/span&gt;
	&lt;span class="c1"&gt;#    break&lt;/span&gt;


&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# the answer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Overall, a nice little problem for beginning and intermediate
students.
&lt;/p&gt;</summary>
    <category term="cs" label="cs"/>
    <category term="pedagogy" label="pedagogy"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>Inverted Index Project</title>
    <id>http://cestlaz.github.io/posts/inverted-index/</id>
    <updated>2016-11-26T16:52:56-05:00</updated>
    <published>2016-11-26T16:52:56-05:00</published>
    <author>
      <name>Mike Zamansky</name>
    </author>
    <link rel="alternate" type="text/html" href="http://cestlaz.github.io/posts/inverted-index/"/>
    <summary type="html">&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
I haven't spoken much about the class I've been teaching this
semester. It's an intro CS course - a programming heavy intro. I
decided to use Python with a transition at the end to C++. The
transition is to mirror Hunter's normal first CS course that ends with
a C++ intro to prepare the students for next semester's CS course
which is a more intense OOP class using C++ - the language we use in
our core courses.
&lt;/p&gt;

&lt;p&gt;
Throughout the semester I've tried to use a variety of interesting
application areas so as to try to give the students some idea of the
possibilities that studying CS will open up for them.
&lt;/p&gt;

&lt;p&gt;
After covering Python dictionaries and lists I thought we'd play by
building an inverted Index.
&lt;/p&gt;

&lt;p&gt;
The basic idea is to map a set of words back to source files. For
example, given the following four one line files:
&lt;/p&gt;


&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="left"&gt;

&lt;col class="left"&gt;

&lt;col class="left"&gt;

&lt;col class="left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="left"&gt;files&lt;/th&gt;
&lt;th scope="col" class="left"&gt; &lt;/th&gt;
&lt;th scope="col" class="left"&gt; &lt;/th&gt;
&lt;th scope="col" class="left"&gt;contents&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;file.01&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;if you prick us do we not bleed&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;file.02&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;if you tickle us do we not laugh&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;file.03&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;if you poison us do we not die and&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;file.04&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;if you wrong us shall we not revenge&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;



&lt;p&gt;
You could build a data structure mapping each word back to the file(s)
that contain it (partially shown here),
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="left"&gt;

&lt;col class="left"&gt;

&lt;col class="left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="left"&gt;Word&lt;/th&gt;
&lt;th scope="col" class="left"&gt; &lt;/th&gt;
&lt;th scope="col" class="left"&gt;Files containing It's&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;if&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;file.01 file.02 file.03 file.04&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;you&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;file.01 file.02 file.03 file.04&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;prick&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;file.01&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;us&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;file.01 file.02 file.03 file.04&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;do&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;file.01 file.02 file.03&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;
You can, of course, store more information - how many times a word
appears in a file, where it appears, etc.
&lt;/p&gt;

&lt;p&gt;
This is a fairly easy structure to build. A dictionary where the keys
are the words in the file and the values are lists of the documents
containing the words.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="n"&gt;inverted_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="s1"&gt;'if'&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'file.01'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.02'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.03'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.04'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="s1"&gt;'you'&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'file.01'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.02'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.03'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.04'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="s1"&gt;'prick'&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'file.01'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="s1"&gt;'us'&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'file.01'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.02'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.03'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.04'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="s1"&gt;'do'&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'file.01'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.02'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'file.03'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In addition to letting us work with dictionaries and lists, we can
also review file access and even the python CSV module if we want.
&lt;/p&gt;

&lt;p&gt;
We can immediately write simple queries – "what document(s) contain
the word 'prick,' but things get more interesting if you write
functions to perform &lt;b&gt;&lt;b&gt;and&lt;/b&gt;&lt;/b&gt; and &lt;b&gt;&lt;b&gt;or&lt;/b&gt;&lt;/b&gt; queries - "what document(s)
contain the words 'prick' &lt;b&gt;&lt;b&gt;or&lt;/b&gt;&lt;/b&gt; 'do'" for instance.
&lt;/p&gt;

&lt;p&gt;
Why are we building this (besides as a data structure and programming
exercise)? I've seen a number of references to using an inverted index
when building a web search engine. In fact, I think that's something
you do early on in the Udacity Mooc. I just wanted to play with
information retrieval.
&lt;/p&gt;

&lt;p&gt;
I remembered that there was a collection of information, including
last statements from &lt;a href="https://www.tdcj.state.tx.us/death_row/dr_executed_offenders.html"&gt;executed offenders in Texas&lt;/a&gt;. Someone conveniently
converted it into a &lt;a href="https://docs.google.com/spreadsheets/d/1HAjZTtPriClY-X3n9whTkA4i5D7bn3bmtHnLoaVICvI/edit#gid=1"&gt;Google Spreadsheet&lt;/a&gt;. The format's a little
different from our simple four file example but then there's more
data. It's straightforward enough to download the spreadsheet as a CSV
file and then read it with a Python program that builds it into an
inverted index.
&lt;/p&gt;

&lt;p&gt;
Now we have some interesting data to play with.
&lt;/p&gt;

&lt;p&gt;
How many offenders used words like "sorry" or "apologize?" How about
references to religion? We can do all sorts of &lt;b&gt;&lt;b&gt;and&lt;/b&gt;&lt;/b&gt; and &lt;b&gt;&lt;b&gt;or&lt;/b&gt;&lt;/b&gt;
queries. 
&lt;/p&gt;

&lt;p&gt;
We just played with this a bit but I could see all sorts of
explorations. What about taking some great work of literature and
turning it into an inverted index by chapter. You could query
characters or certain words and see where and when they appear in the
book. A new and different way of exploring literature.
&lt;/p&gt;

&lt;p&gt;
So, there you have it - an interesting little project we played with
this past semester. We did it in an intro Python course but I could
see it as an interesting project in AP CS A using hashmaps and lists.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</summary>
    <category term="cs" label="cs"/>
    <category term="intro" label="intro"/>
    <category term="programming" label="programming"/>
    <category term="python" label="python"/>
  </entry>
</feed>
